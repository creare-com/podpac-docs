

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>xarray.core.dataarray &mdash; 1.1.0</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  
    <link rel="canonical" href="https://podpac.org_modules/xarray/core/dataarray.html"/>
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/icon.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../why-podpac.html">Why PODPAC?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasets.html">Supported Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Development Roadmap</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/settings.html">Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/coordinates.html">Coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/nodes.html">Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/pipelines.html">Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/cache.html">Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/earthdata.html">NASA Earth Data Login</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/api.html">API Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/aws.html">AWS Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/docs.html">Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PODPAC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>xarray.core.dataarray</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for xarray.core.dataarray</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">..plot.plot</span> <span class="k">import</span> <span class="n">_PlotMethods</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">computation</span><span class="p">,</span>
    <span class="n">dtypes</span><span class="p">,</span>
    <span class="n">groupby</span><span class="p">,</span>
    <span class="n">indexing</span><span class="p">,</span>
    <span class="n">ops</span><span class="p">,</span>
    <span class="n">pdcompat</span><span class="p">,</span>
    <span class="n">resample</span><span class="p">,</span>
    <span class="n">rolling</span><span class="p">,</span>
    <span class="n">utils</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.accessor_dt</span> <span class="k">import</span> <span class="n">DatetimeAccessor</span>
<span class="kn">from</span> <span class="nn">.accessor_str</span> <span class="k">import</span> <span class="n">StringAccessor</span>
<span class="kn">from</span> <span class="nn">.alignment</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">_broadcast_helper</span><span class="p">,</span>
    <span class="n">_get_broadcast_dims_map_common_coords</span><span class="p">,</span>
    <span class="n">align</span><span class="p">,</span>
    <span class="n">reindex_like_indexers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.common</span> <span class="k">import</span> <span class="n">AbstractArray</span><span class="p">,</span> <span class="n">DataWithCoords</span>
<span class="kn">from</span> <span class="nn">.coordinates</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">DataArrayCoordinates</span><span class="p">,</span>
    <span class="n">LevelCoordinatesSource</span><span class="p">,</span>
    <span class="n">assert_coordinate_consistent</span><span class="p">,</span>
    <span class="n">remap_label_indexers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.dataset</span> <span class="k">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">merge_indexes</span><span class="p">,</span> <span class="n">split_indexes</span>
<span class="kn">from</span> <span class="nn">.formatting</span> <span class="k">import</span> <span class="n">format_item</span>
<span class="kn">from</span> <span class="nn">.indexes</span> <span class="k">import</span> <span class="n">Indexes</span><span class="p">,</span> <span class="n">default_indexes</span>
<span class="kn">from</span> <span class="nn">.options</span> <span class="k">import</span> <span class="n">OPTIONS</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">ReprObject</span><span class="p">,</span> <span class="n">_check_inplace</span><span class="p">,</span> <span class="n">either_dict_or_kwargs</span>
<span class="kn">from</span> <span class="nn">.variable</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">IndexVariable</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">,</span>
    <span class="n">as_compatible_data</span><span class="p">,</span>
    <span class="n">as_variable</span><span class="p">,</span>
    <span class="n">assert_unique_multiindex_level_names</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="n">T_DSorDA</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T_DSorDA&quot;</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dask.delayed</span> <span class="k">import</span> <span class="n">Delayed</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">Delayed</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">cdms2</span> <span class="k">import</span> <span class="n">Variable</span> <span class="k">as</span> <span class="n">cdms2_Variable</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">cdms2_Variable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">iris.cube</span> <span class="k">import</span> <span class="n">Cube</span> <span class="k">as</span> <span class="n">iris_Cube</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">iris_Cube</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_infer_coords_and_dims</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Tuple[Dict[Any, Variable], Tuple[Hashable, ...]]&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;All the logic for creating a new DataArray&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;coords is not dict-like, but it has </span><span class="si">%s</span><span class="s2"> items, &quot;</span>
            <span class="s2">&quot;which does not match the </span><span class="si">%s</span><span class="s2"> dimensions of the &quot;</span>
            <span class="s2">&quot;data&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;dim_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="c1"># try to infer dimensions from coords</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="c1"># deprecated in GH993, removed in GH1539</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;inferring DataArray dimensions from &quot;</span>
                    <span class="s2">&quot;dictionary like ``coords`` is no longer &quot;</span>
                    <span class="s2">&quot;supported. Use an explicit list of &quot;</span>
                    <span class="s2">&quot;``dims`` instead.&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="p">)):</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">dims</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>
                <span class="n">dims</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;different number of dimensions on data &quot;</span>
            <span class="s2">&quot;and dims: </span><span class="si">%s</span><span class="s2"> vs </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;dimension </span><span class="si">%s</span><span class="s2"> is not a string&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>

    <span class="n">new_coords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">as_variable</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span>
            <span class="n">new_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">to_index_variable</span><span class="p">()</span>

    <span class="n">sizes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;coordinate </span><span class="si">%s</span><span class="s2"> has dimensions </span><span class="si">%s</span><span class="s2">, but these &quot;</span>
                <span class="s2">&quot;are not a subset of the DataArray &quot;</span>
                <span class="s2">&quot;dimensions </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;conflicting sizes for dimension </span><span class="si">%r</span><span class="s2">: &quot;</span>
                    <span class="s2">&quot;length </span><span class="si">%s</span><span class="s2"> on the data but length </span><span class="si">%s</span><span class="s2"> on &quot;</span>
                    <span class="s2">&quot;coordinate </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sizes</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">k</span><span class="p">],):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;coordinate </span><span class="si">%r</span><span class="s2"> is a DataArray dimension, but &quot;</span>
                <span class="s2">&quot;it has shape </span><span class="si">%r</span><span class="s2"> rather than expected shape </span><span class="si">%r</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;matching the dimension size&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">k</span><span class="p">],))</span>
            <span class="p">)</span>

    <span class="n">assert_unique_multiindex_level_names</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_coords</span><span class="p">,</span> <span class="n">dims</span>


<span class="k">def</span> <span class="nf">_check_data_shape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">include_0d</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">as_variable</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dims</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">as_variable</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">class</span> <span class="nc">_LocIndexer</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;data_array&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_array</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># expand the indexer so we can handle Ellipsis</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">indexing</span><span class="o">.</span><span class="n">expanded_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># expand the indexer so we can handle Ellipsis</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">indexing</span><span class="o">.</span><span class="n">expanded_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>

        <span class="n">pos_indexers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">remap_label_indexers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">[</span><span class="n">pos_indexers</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="c1"># Used as the key corresponding to a DataArray&#39;s variable when converting</span>
<span class="c1"># arbitrary DataArray objects to datasets</span>
<span class="n">_THIS_ARRAY</span> <span class="o">=</span> <span class="n">ReprObject</span><span class="p">(</span><span class="s2">&quot;&lt;this-array&gt;&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DataArray</span><span class="p">(</span><span class="n">AbstractArray</span><span class="p">,</span> <span class="n">DataWithCoords</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;N-dimensional array with labeled coordinates and dimensions.</span>

<span class="sd">    DataArray provides a wrapper around numpy ndarrays that uses labeled</span>
<span class="sd">    dimensions and coordinates to support metadata aware operations. The API is</span>
<span class="sd">    similar to that for the pandas Series or DataFrame, but DataArray objects</span>
<span class="sd">    can have any number of dimensions, and their contents have fixed data</span>
<span class="sd">    types.</span>

<span class="sd">    Additional features over raw numpy arrays:</span>

<span class="sd">    - Apply operations over dimensions by name: ``x.sum(&#39;time&#39;)``.</span>
<span class="sd">    - Select or assign values by integer location (like numpy): ``x[:10]``</span>
<span class="sd">      or by label (like pandas): ``x.loc[&#39;2014-01-01&#39;]`` or</span>
<span class="sd">      ``x.sel(time=&#39;2014-01-01&#39;)``.</span>
<span class="sd">    - Mathematical operations (e.g., ``x - y``) vectorize across multiple</span>
<span class="sd">      dimensions (known in numpy as &quot;broadcasting&quot;) based on dimension names,</span>
<span class="sd">      regardless of their original order.</span>
<span class="sd">    - Keep track of arbitrary metadata in the form of a Python dictionary:</span>
<span class="sd">      ``x.attrs``</span>
<span class="sd">    - Convert to a pandas Series: ``x.to_series()``.</span>

<span class="sd">    Getting items from or doing mathematical operations with a DataArray</span>
<span class="sd">    always returns another DataArray.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dims : tuple</span>
<span class="sd">        Dimension names associated with this array.</span>
<span class="sd">    values : np.ndarray</span>
<span class="sd">        Access or modify DataArray values as a numpy array.</span>
<span class="sd">    coords : dict-like</span>
<span class="sd">        Dictionary of DataArray objects that label values along each dimension.</span>
<span class="sd">    name : str or None</span>
<span class="sd">        Name of this array.</span>
<span class="sd">    attrs : dict</span>
<span class="sd">        Dictionary for holding arbitrary metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_accessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
    <span class="n">_coords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span>
    <span class="n">_indexes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]]</span>
    <span class="n">_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="n">_variable</span><span class="p">:</span> <span class="n">Variable</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;_accessors&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_coords&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_file_obj&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_indexes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_variable&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__weakref__&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">_groupby_cls</span> <span class="o">=</span> <span class="n">groupby</span><span class="o">.</span><span class="n">DataArrayGroupBy</span>
    <span class="n">_rolling_cls</span> <span class="o">=</span> <span class="n">rolling</span><span class="o">.</span><span class="n">DataArrayRolling</span>
    <span class="n">_coarsen_cls</span> <span class="o">=</span> <span class="n">rolling</span><span class="o">.</span><span class="n">DataArrayCoarsen</span>
    <span class="n">_resample_cls</span> <span class="o">=</span> <span class="n">resample</span><span class="o">.</span><span class="n">DataArrayResample</span>

    <span class="n">__default</span> <span class="o">=</span> <span class="n">ReprObject</span><span class="p">(</span><span class="s2">&quot;&lt;default&gt;&quot;</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">DatetimeAccessor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># deprecated parameters</span>
        <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># internal parameters</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fastpath</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array_like</span>
<span class="sd">            Values for this array. Must be an ``numpy.ndarray``, ndarray like,</span>
<span class="sd">            or castable to an ``ndarray``. If a self-described xarray or pandas</span>
<span class="sd">            object, attempts are made to use this array&#39;s metadata to fill in</span>
<span class="sd">            other unspecified arguments. A view of the array&#39;s data is used</span>
<span class="sd">            instead of a copy if possible.</span>
<span class="sd">        coords : sequence or dict of array_like objects, optional</span>
<span class="sd">            Coordinates (tick labels) to use for indexing along each dimension.</span>
<span class="sd">            The following notations are accepted:</span>

<span class="sd">            - mapping {dimension name: array-like}</span>
<span class="sd">            - sequence of tuples that are valid arguments for xarray.Variable()</span>
<span class="sd">              - (dims, data)</span>
<span class="sd">              - (dims, data, attrs)</span>
<span class="sd">              - (dims, data, attrs, encoding)</span>

<span class="sd">            Additionally, it is possible to define a coord whose name</span>
<span class="sd">            does not match the dimension name, or a coord based on multiple</span>
<span class="sd">            dimensions, with one of the following notations:</span>

<span class="sd">            - mapping {coord name: DataArray}</span>
<span class="sd">            - mapping {coord name: Variable}</span>
<span class="sd">            - mapping {coord name: (dimension name, array-like)}</span>
<span class="sd">            - mapping {coord name: (tuple of dimension names, array-like)}</span>

<span class="sd">        dims : hashable or sequence of hashable, optional</span>
<span class="sd">            Name(s) of the data dimension(s). Must be either a hashable (only</span>
<span class="sd">            for 1D data) or a sequence of hashables with length equal to the</span>
<span class="sd">            number of dimensions. If this argument is omitted, dimension names</span>
<span class="sd">            are taken from ``coords`` (if possible) and otherwise default to</span>
<span class="sd">            ``[&#39;dim_0&#39;, ... &#39;dim_n&#39;]``.</span>
<span class="sd">        name : str or None, optional</span>
<span class="sd">            Name of this array.</span>
<span class="sd">        attrs : dict_like or None, optional</span>
<span class="sd">            Attributes to assign to the new instance. By default, an empty</span>
<span class="sd">            attribute dictionary is initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The `encoding` argument to `DataArray` is deprecated, and . &quot;</span>
                <span class="s2">&quot;will be removed in 0.15. &quot;</span>
                <span class="s2">&quot;Instead, specify the encoding when writing to disk or &quot;</span>
                <span class="s2">&quot;set the `encoding` attribute directly.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">assert</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try to fill in arguments from data if they weren&#39;t supplied</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coords</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">)):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pdcompat</span><span class="o">.</span><span class="n">Panel</span><span class="p">):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">major_axis</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">minor_axis</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dims&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;dims&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;attrs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">_check_data_shape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">as_compatible_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">_infer_coords_and_dims</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># These fully describe a DataArray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accessors</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO(shoyer): document this argument, once it becomes part of the</span>
        <span class="c1"># public interface.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">indexes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_file_obj</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variable</span><span class="p">:</span> <span class="n">Variable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="n">__default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__default</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_maybe_drop_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="n">__default</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="ow">and</span> <span class="n">variable</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">variable</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="c1"># Shape has changed (e.g. from reduce(..., keepdims=True)</span>
            <span class="n">new_sizes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">variable</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allowed_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">allowed_dims</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_overwrite_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># switch from dimension to level names, if necessary</span>
        <span class="n">dim_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="n">dim_names</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">dim_names</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_to_temp_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataset_whole</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">_THIS_ARRAY</span><span class="p">,</span> <span class="n">shallow_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_temp_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="n">__default</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">_THIS_ARRAY</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">_variables</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_dataset_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[{</span><span class="n">dim</span><span class="p">:</span> <span class="n">label</span><span class="p">}]</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">array</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">return</span> <span class="n">array</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">subset</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)}</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_dataset_whole</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">shallow_copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;unable to convert unnamed DataArray to a &quot;</span>
                <span class="s2">&quot;Dataset without providing an explicit name&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot create a Dataset from a DataArray with &quot;</span>
                <span class="s2">&quot;the same name as one of its coordinates&quot;</span>
            <span class="p">)</span>
        <span class="c1"># use private APIs for speed: this is called by _to_temp_dataset(),</span>
        <span class="c1"># which is used in the guts of a lot of operations (e.g., reindex)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">shallow_copy</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">_from_vars_and_coord_names</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">to_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a DataArray to a Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable, optional</span>
<span class="sd">            Name of the dimension on this array along which to split this array</span>
<span class="sd">            into separate variables. If not provided, this array is converted</span>
<span class="sd">            into a Dataset of one variable.</span>
<span class="sd">        name : hashable, optional</span>
<span class="sd">            Name to substitute for this array&#39;s name. Only valid if ``dim`` is</span>
<span class="sd">            not provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dataset : Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a dim. If supplying a ``name``, pass as a kwarg.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot supply both dim and name arguments&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataset_split</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataset_whole</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The name of this array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Variable</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Low level interface to the Variable object for this DataArray.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The array&#39;s data as a dask or numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The array&#39;s data as a numpy.ndarray&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_in_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">_in_memory</span>

    <span class="k">def</span> <span class="nf">to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this variable to a pandas.Index. Only possible for 1D</span>
<span class="sd">        arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Tuple of dimension names associated with this array.</span>

<span class="sd">        Note that the type of this property is inconsistent with</span>
<span class="sd">        `Dataset.dims`.  See `Dataset.sizes` and `DataArray.sizes` for</span>
<span class="sd">        consistently named properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">dims</span>

    <span class="nd">@dims</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;you cannot assign dims on a DataArray. Use &quot;</span>
            <span class="s2">&quot;.rename() or .swap_dims() instead.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_item_key_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">indexing</span><span class="o">.</span><span class="n">expanded_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_level_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a mapping of all MultiIndex levels and their corresponding</span>
<span class="sd">        coordinate name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">level_coords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cname</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">IndexVariable</span><span class="p">):</span>
                <span class="n">level_names</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">level_names</span>
                <span class="k">if</span> <span class="n">level_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dim</span><span class="p">,</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span>
                    <span class="n">level_coords</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lname</span><span class="p">:</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">lname</span> <span class="ow">in</span> <span class="n">level_names</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">level_coords</span>

    <span class="k">def</span> <span class="nf">_getitem_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.dataset</span> <span class="k">import</span> <span class="n">_get_virtual_variable</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">dim_sizes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_get_virtual_variable</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_coords</span><span class="p">,</span> <span class="n">dim_sizes</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_maybe_drop_dims</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_coord</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># xarray-style array indexing</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">indexers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_item_key_to_dict</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Coordinates in key, value and self[key] should be consistent.</span>
            <span class="c1"># TODO Coordinate consistency in key is checked here, but it</span>
            <span class="c1"># causes unnecessary indexing. It should be optimized.</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="n">assert_coordinate_consistent</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="c1"># DataArray key -&gt; Variable key</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">variable</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_key_to_dict</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_attr_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of places to look-up items for attribute-style access</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_sources</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_item_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of places to look-up items for key-completion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
            <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">},</span>
            <span class="n">LevelCoordinatesSource</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_LocIndexer</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attribute for location based indexing like pandas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_LocIndexer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary storing arbitrary metadata with this array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">attrs</span>

    <span class="nd">@attrs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Disable type checking to work around mypy bug - see mypy#4167</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of format-specific settings for how this array should be</span>
<span class="sd">        serialized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">encoding</span>

    <span class="nd">@encoding</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Indexes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mapping of pandas.Index objects used for label based indexing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="n">default_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArrayCoordinates</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary-like container of coordinate arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataArrayCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Given names of coordinates, reset them to become variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : hashable or iterable of hashables, optional</span>
<span class="sd">            Name(s) of non-index coordinates in this dataset to reset into</span>
<span class="sd">            variables. By default, all non-index coordinates are reset.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If True, remove coordinates instead of converting them into</span>
<span class="sd">            variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset, or DataArray if ``drop == True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_inplace</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">drop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot reset_coords with drop=False on an unnamed DataArrray&quot;</span>
                <span class="p">)</span>
            <span class="n">dataset</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
            <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">__dask_graph__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__dask_keys__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__dask_layers__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_layers__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__dask_optimize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_optimize__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__dask_scheduler__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_scheduler__</span>

    <span class="k">def</span> <span class="nf">__dask_postcompute__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_postcompute__</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dask_finalize</span><span class="p">,</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dask_postpersist__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">__dask_postpersist__</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dask_finalize</span><span class="p">,</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_dask_finalize</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">_THIS_ARRAY</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">_variables</span>
        <span class="k">return</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Manually trigger loading of this array&#39;s data from disk or a</span>
<span class="sd">        remote source into memory and return this array.</span>

<span class="sd">        Normally, it should not be necessary to call this method in user code,</span>
<span class="sd">        because all xarray functions should either work on deferred data or</span>
<span class="sd">        load data automatically. However, this method can be necessary when</span>
<span class="sd">        working with many file objects on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.array.compute``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.compute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">_variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">_coords</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Manually trigger loading of this array&#39;s data from disk or a</span>
<span class="sd">        remote source into memory and return a new array. The original is</span>
<span class="sd">        left unaltered.</span>

<span class="sd">        Normally, it should not be necessary to call this method in user code,</span>
<span class="sd">        because all xarray functions should either work on deferred data or</span>
<span class="sd">        load data automatically. However, this method can be necessary when</span>
<span class="sd">        working with many file objects on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.array.compute``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.compute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Trigger computation in constituent dask arrays</span>

<span class="sd">        This keeps them as dask arrays but encourages them to keep data in</span>
<span class="sd">        memory.  This is particularly useful when on a distributed machine.</span>
<span class="sd">        When on a single machine consider using ``.compute()`` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to ``dask.persist``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.persist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of this array.</span>

<span class="sd">        If `deep=True`, a deep copy is made of the data array.</span>
<span class="sd">        Otherwise, a shallow copy is made, so each variable in the new</span>
<span class="sd">        array&#39;s dataset is also a variable in this array&#39;s dataset.</span>

<span class="sd">        Use `data` to create a new object with the same structure as</span>
<span class="sd">        original but entirely new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, optional</span>
<span class="sd">            Whether the data array and its coordinates are loaded into memory</span>
<span class="sd">            and copied onto the new object. Default is True.</span>
<span class="sd">        data : array_like, optional</span>
<span class="sd">            Data to use in the new object. Must have same shape as original.</span>
<span class="sd">            When `data` is used, `deep` is ignored for all data variables,</span>
<span class="sd">            and only used for coords.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object : DataArray</span>
<span class="sd">            New object with dimensions, attributes, coordinates, name,</span>
<span class="sd">            encoding, and optionally data copied from original.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Shallow versus deep copy</span>

<span class="sd">        &gt;&gt;&gt; array = xr.DataArray([1, 2, 3], dims=&#39;x&#39;,</span>
<span class="sd">        ...                      coords={&#39;x&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; array.copy()</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([1, 2, 3])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &gt;&gt;&gt; array_0 = array.copy(deep=False)</span>
<span class="sd">        &gt;&gt;&gt; array_0[0] = 7</span>
<span class="sd">        &gt;&gt;&gt; array_0</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([7, 2, 3])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &gt;&gt;&gt; array</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([7, 2, 3])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>

<span class="sd">        Changing the data using the ``data`` argument maintains the</span>
<span class="sd">        structure of the original object, but with the new data. Original</span>
<span class="sd">        object is unaffected.</span>

<span class="sd">        &gt;&gt;&gt; array.copy(data=[0.1, 0.2, 0.3])</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([ 0.1,  0.2,  0.3])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &gt;&gt;&gt; array</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([1, 2, 3])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="c1"># memo does nothing but is required for compatibility with</span>
        <span class="c1"># copy.deepcopy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># mutable objects should not be hashable</span>
    <span class="c1"># https://github.com/python/mypy/issues/4266</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Block dimensions for this array&#39;s data or None if it&#39;s not a dask</span>
<span class="sd">        array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">chunks</span>

    <span class="k">def</span> <span class="nf">chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">Number</span><span class="p">,</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
            <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Number</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="o">...</span><span class="p">]]],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xarray-&quot;</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Coerce this array&#39;s data into a dask arrays with the given chunks.</span>

<span class="sd">        If this variable is a non-dask array, it will be converted to dask</span>
<span class="sd">        array. If it&#39;s a dask array, it will be rechunked to the given chunk</span>
<span class="sd">        sizes.</span>

<span class="sd">        If neither chunks is not provided for one or more dimensions, chunk</span>
<span class="sd">        sizes along that dimension will not be updated; non-dask arrays will be</span>
<span class="sd">        converted into dask arrays with a single block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunks : int, tuple or mapping, optional</span>
<span class="sd">            Chunk sizes along each dimension, e.g., ``5``, ``(5, 5)`` or</span>
<span class="sd">            ``{&#39;x&#39;: 5, &#39;y&#39;: 5}``.</span>
<span class="sd">        name_prefix : str, optional</span>
<span class="sd">            Prefix for the name of the new dask array.</span>
<span class="sd">        token : str, optional</span>
<span class="sd">            Token uniquely identifying this array.</span>
<span class="sd">        lock : optional</span>
<span class="sd">            Passed on to :py:func:`dask.array.from_array`, if the array is not</span>
<span class="sd">            already as dask array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chunked : xarray.DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">chunks</span><span class="p">))</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span>
            <span class="n">chunks</span><span class="p">,</span> <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">token</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new DataArray whose data is given by integer indexing</span>
<span class="sd">        along the specified dimension(s).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.isel</span>
<span class="sd">        DataArray.sel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;isel&quot;</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">,</span> <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new DataArray whose data is given by selecting index</span>
<span class="sd">        labels along the specified dimension(s).</span>

<span class="sd">        .. warning::</span>

<span class="sd">          Do not try to assign values when using any of the indexing methods</span>
<span class="sd">          ``isel`` or ``sel``::</span>

<span class="sd">            da = xr.DataArray([0, 1, 2, 3], dims=[&#39;x&#39;])</span>
<span class="sd">            # DO NOT do this</span>
<span class="sd">            da.isel(x=[0, 1, 2])[1] = -1</span>

<span class="sd">          Assigning values with the chained indexing using ``.sel`` or</span>
<span class="sd">          ``.isel`` fails silently.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.sel</span>
<span class="sd">        DataArray.isel</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
            <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span>
            <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="o">**</span><span class="n">indexers_kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new DataArray whose data is given by the the first `n`</span>
<span class="sd">        values along the specified dimension(s). Default `n` = 5</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.head</span>
<span class="sd">        DataArray.tail</span>
<span class="sd">        DataArray.thin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new DataArray whose data is given by the the last `n`</span>
<span class="sd">        values along the specified dimension(s). Default `n` = 5</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.tail</span>
<span class="sd">        DataArray.head</span>
<span class="sd">        DataArray.thin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">thin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new DataArray whose data is given by each `n` value</span>
<span class="sd">        along the specified dimension(s). Default `n` = 5</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.thin</span>
<span class="sd">        DataArray.head</span>
<span class="sd">        DataArray.tail</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">thin</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">broadcast_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">],</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Broadcast this DataArray against another Dataset or DataArray.</span>

<span class="sd">        This is equivalent to xr.broadcast(other, self)[1]</span>

<span class="sd">        xarray objects are broadcast against each other in arithmetic</span>
<span class="sd">        operations, so this method is not be necessary for most uses.</span>

<span class="sd">        If no change is needed, the input data is returned to the output</span>
<span class="sd">        without being copied.</span>

<span class="sd">        If new coords are added by the broadcast, their values are</span>
<span class="sd">        NaN filled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object against which to broadcast this array.</span>
<span class="sd">        exclude : iterable of hashable, optional</span>
<span class="sd">            Dimensions that must not be broadcasted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_da: xr.DataArray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; arr1</span>
<span class="sd">        &lt;xarray.DataArray (x: 2, y: 3)&gt;</span>
<span class="sd">        array([[0.840235, 0.215216, 0.77917 ],</span>
<span class="sd">               [0.726351, 0.543824, 0.875115]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &gt;&gt;&gt; arr2</span>
<span class="sd">        &lt;xarray.DataArray (x: 3, y: 2)&gt;</span>
<span class="sd">        array([[0.612611, 0.125753],</span>
<span class="sd">               [0.853181, 0.948818],</span>
<span class="sd">               [0.180885, 0.33363 ]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">          * y        (y) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">        &gt;&gt;&gt; arr1.broadcast_like(arr2)</span>
<span class="sd">        &lt;xarray.DataArray (x: 3, y: 3)&gt;</span>
<span class="sd">        array([[0.840235, 0.215216, 0.77917 ],</span>
<span class="sd">               [0.726351, 0.543824, 0.875115],</span>
<span class="sd">               [     nan,      nan,      nan]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) object &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">          * y        (y) object &#39;a&#39; &#39;b&#39; &#39;c&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">dims_map</span><span class="p">,</span> <span class="n">common_coords</span> <span class="o">=</span> <span class="n">_get_broadcast_dims_map_common_coords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_broadcast_helper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">dims_map</span><span class="p">,</span> <span class="n">common_coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conform this object onto the indexes of another object, filling in</span>
<span class="sd">        missing values with ``fill_value``. The default fill value is NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object with an &#39;indexes&#39; attribute giving a mapping from dimension</span>
<span class="sd">            names to pandas.Index objects, which provides coordinates upon</span>
<span class="sd">            which to index the variables in this dataset. The indexes on this</span>
<span class="sd">            other object need not be the same as the indexes on this</span>
<span class="sd">            dataset. Any mis-matched index values will be filled in with</span>
<span class="sd">            NaN, and any mis-matched dimension names will simply be ignored.</span>
<span class="sd">        method : {None, &#39;nearest&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;}, optional</span>
<span class="sd">            Method to use for filling index values from other not found on this</span>
<span class="sd">            data array:</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid index value forward</span>
<span class="sd">            * backfill / bfill: propagate next valid index value backward</span>
<span class="sd">            * nearest: use nearest valid index value</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If ``copy=True``, data in the return value is always copied. If</span>
<span class="sd">            ``copy=False`` and reindexing is unnecessary, or can be performed</span>
<span class="sd">            with only slice operations, then the output may share memory with</span>
<span class="sd">            the input. In either case, a new xarray object is always returned.</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            Value to use for newly missing values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : DataArray</span>
<span class="sd">            Another dataset array, with this array&#39;s data but coordinates from</span>
<span class="sd">            the other object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.reindex</span>
<span class="sd">        align</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">reindex_like_indexers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexers</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexers_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conform this object onto the indexes of another object, filling in</span>
<span class="sd">        missing values with ``fill_value``. The default fill value is NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexers : dict, optional</span>
<span class="sd">            Dictionary with keys given by dimension names and values given by</span>
<span class="sd">            arrays of coordinates tick labels. Any mis-matched coordinate</span>
<span class="sd">            values will be filled in with NaN, and any mis-matched dimension</span>
<span class="sd">            names will simply be ignored.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            If ``copy=True``, data in the return value is always copied. If</span>
<span class="sd">            ``copy=False`` and reindexing is unnecessary, or can be performed</span>
<span class="sd">            with only slice operations, then the output may share memory with</span>
<span class="sd">            the input. In either case, a new xarray object is always returned.</span>
<span class="sd">        method : {None, &#39;nearest&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;}, optional</span>
<span class="sd">            Method to use for filling index values in ``indexers`` not found on</span>
<span class="sd">            this data array:</span>

<span class="sd">            * None (default): don&#39;t fill gaps</span>
<span class="sd">            * pad / ffill: propagate last valid index value forward</span>
<span class="sd">            * backfill / bfill: propagate next valid index value backward</span>
<span class="sd">            * nearest: use nearest valid index value</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations must</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            Value to use for newly missing values</span>
<span class="sd">        **indexers_kwarg : {dim: indexer, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``indexers``.</span>
<span class="sd">            One of indexers or indexers_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : DataArray</span>
<span class="sd">            Another dataset array, with this array&#39;s data but replaced</span>
<span class="sd">            coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.reindex_like</span>
<span class="sd">        align</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexers</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexers</span><span class="p">,</span> <span class="n">indexers_kwargs</span><span class="p">,</span> <span class="s2">&quot;reindex&quot;</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">indexers</span><span class="o">=</span><span class="n">indexers</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">coords_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Multidimensional interpolation of variables.</span>

<span class="sd">        coords : dict, optional</span>
<span class="sd">            Mapping from dimension names to the new coordinates.</span>
<span class="sd">            new coordinate can be an scalar, array-like or DataArray.</span>
<span class="sd">            If DataArrays are passed as new coordates, their dimensions are</span>
<span class="sd">            used for the broadcasting.</span>
<span class="sd">        method: {&#39;linear&#39;, &#39;nearest&#39;} for multidimensional array,</span>
<span class="sd">            {&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;}</span>
<span class="sd">            for 1-dimensional array.</span>
<span class="sd">        assume_sorted: boolean, optional</span>
<span class="sd">            If False, values of x can be in any order and they are sorted</span>
<span class="sd">            first. If True, x has to be an array of monotonically increasing</span>
<span class="sd">            values.</span>
<span class="sd">        kwargs: dictionary</span>
<span class="sd">            Additional keyword passed to scipy&#39;s interpolator.</span>
<span class="sd">        **coords_kwarg : {dim: coordinate, ...}, optional</span>
<span class="sd">            The keyword arguments form of ``coords``.</span>
<span class="sd">            One of coords or coords_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated: xr.DataArray</span>
<span class="sd">            New dataarray on the new coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        scipy is required.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.interpolate.interp1d</span>
<span class="sd">        scipy.interpolate.interpn</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; da = xr.DataArray([1, 3], [(&#39;x&#39;, np.arange(2))])</span>
<span class="sd">        &gt;&gt;&gt; da.interp(x=0.5)</span>
<span class="sd">        &lt;xarray.DataArray ()&gt;</span>
<span class="sd">        array(2.0)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        float64 0.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;uifc&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;interp only works for a numeric type array. &quot;</span>
                <span class="s2">&quot;Given </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="n">assume_sorted</span><span class="p">,</span>
            <span class="o">**</span><span class="n">coords_kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interp_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Interpolate this object onto the coordinates of another object,</span>
<span class="sd">        filling out of range values with NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Dataset or DataArray</span>
<span class="sd">            Object with an &#39;indexes&#39; attribute giving a mapping from dimension</span>
<span class="sd">            names to an 1d array-like, which provides coordinates upon</span>
<span class="sd">            which to index the variables in this dataset.</span>
<span class="sd">        method: string, optional.</span>
<span class="sd">            {&#39;linear&#39;, &#39;nearest&#39;} for multidimensional array,</span>
<span class="sd">            {&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;}</span>
<span class="sd">            for 1-dimensional array. &#39;linear&#39; is used by default.</span>
<span class="sd">        assume_sorted: boolean, optional</span>
<span class="sd">            If False, values of coordinates that are interpolated over can be</span>
<span class="sd">            in any order and they are sorted first. If True, interpolated</span>
<span class="sd">            coordinates are assumed to be an array of monotonically increasing</span>
<span class="sd">            values.</span>
<span class="sd">        kwargs: dictionary, optional</span>
<span class="sd">            Additional keyword passed to scipy&#39;s interpolator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated: xr.DataArray</span>
<span class="sd">            Another dataarray by interpolating this dataarray&#39;s data along the</span>
<span class="sd">            coordinates of the other object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        scipy is required.</span>
<span class="sd">        If the dataarray has object-type coordinates, reindex is used for these</span>
<span class="sd">        coordinates instead of the interpolation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.interp</span>
<span class="sd">        DataArray.reindex_like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;uifc&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;interp only works for a numeric type array. &quot;</span>
                <span class="s2">&quot;Given </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="n">assume_sorted</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_name_or_name_dict</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new DataArray with renamed coordinates or a new name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_name_or_name_dict : str or dict-like, optional</span>
<span class="sd">            If the argument is dict-like, it used as a mapping from old</span>
<span class="sd">            names to new names for coordinates. Otherwise, use the argument</span>
<span class="sd">            as the new name for this array.</span>
<span class="sd">        **names: hashable, optional</span>
<span class="sd">            The keyword arguments form of a mapping from old names to</span>
<span class="sd">            new names for coordinates.</span>
<span class="sd">            One of new_name_or_name_dict or names must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : DataArray</span>
<span class="sd">            Renamed array or array with renamed coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.rename</span>
<span class="sd">        DataArray.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">or</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">new_name_or_name_dict</span><span class="p">):</span>
            <span class="n">new_name_or_name_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">],</span> <span class="n">new_name_or_name_dict</span>
            <span class="p">)</span>
            <span class="n">name_dict</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">new_name_or_name_dict</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;rename&quot;</span><span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_name_or_name_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">new_name_or_name_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">new_name_or_name_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swap_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new DataArray with swapped dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_dict : dict-like</span>
<span class="sd">            Dictionary whose keys are current dimension names and whose values</span>
<span class="sd">            are new names. Each value must already be a coordinate on this</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : DataArray</span>
<span class="sd">            DataArray with swapped dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray(data=[0, 1], dims=&quot;x&quot;,</span>
<span class="sd">                               coords={&quot;x&quot;: [&quot;a&quot;, &quot;b&quot;], &quot;y&quot;: (&quot;x&quot;, [0, 1])})</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        &lt;xarray.DataArray (x: 2)&gt;</span>
<span class="sd">        array([0, 1])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">            y        (x) int64 0 1</span>
<span class="sd">        &gt;&gt;&gt; arr.swap_dims({&quot;x&quot;: &quot;y&quot;})</span>
<span class="sd">        &lt;xarray.DataArray (y: 2)&gt;</span>
<span class="sd">        array([0, 1])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">            x        (y) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 0 1</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        DataArray.rename</span>
<span class="sd">        Dataset.swap_dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">swap_dims</span><span class="p">(</span><span class="n">dims_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new object with an additional axis (or axes) inserted at</span>
<span class="sd">        the corresponding position in the array shape. The new object is a</span>
<span class="sd">        view into the underlying array, not a copy.</span>


<span class="sd">        If dim is already a scalar coordinate, it will be promoted to a 1D</span>
<span class="sd">        coordinate consisting of a single value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable, sequence of hashable, dict, or None</span>
<span class="sd">            Dimensions to include on the new variable.</span>
<span class="sd">            If provided as str or sequence of str, then dimensions are inserted</span>
<span class="sd">            with length 1. If provided as a dict, then the keys are the new</span>
<span class="sd">            dimensions and the values are either integers (giving the length of</span>
<span class="sd">            the new dimensions) or sequence/ndarray (giving the coordinates of</span>
<span class="sd">            the new dimensions).</span>
<span class="sd">        axis : integer, list (or tuple) of integers, or None</span>
<span class="sd">            Axis position(s) where new axis is to be inserted (position(s) on</span>
<span class="sd">            the result array). If a list (or tuple) of integers is passed,</span>
<span class="sd">            multiple axes are inserted. In this case, dim arguments should be</span>
<span class="sd">            same length list. If axis=None is passed, all the axes will be</span>
<span class="sd">            inserted to the start of the result array.</span>
<span class="sd">        **dim_kwargs : int or sequence/ndarray</span>
<span class="sd">            The keywords are arbitrary dimensions being inserted and the values</span>
<span class="sd">            are either the lengths of the new dims (if int is given), or their</span>
<span class="sd">            coordinates. Note, this is an alternative to passing a dict to the</span>
<span class="sd">            dim kwarg and will only be used if dim is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expanded : same type as caller</span>
<span class="sd">            This object, but with an additional dimension(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;dim should be hashable or sequence/mapping of hashables&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dim</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dims should not contain duplicate values.&quot;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">cast</span><span class="p">(</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim_kwargs</span><span class="p">,</span> <span class="s2">&quot;expand_dims&quot;</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">indexes_kwargs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Set DataArray (multi-)indexes using one or more existing</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexes : {dim: index, ...}</span>
<span class="sd">            Mapping from names matching dimensions and values given</span>
<span class="sd">            by (lists of) the names of existing coordinates or variables to set</span>
<span class="sd">            as new (multi-)index.</span>
<span class="sd">        append : bool, optional</span>
<span class="sd">            If True, append the supplied index(es) to the existing index(es).</span>
<span class="sd">            Otherwise replace the existing index(es) (default).</span>
<span class="sd">        **indexes_kwargs: optional</span>
<span class="sd">            The keyword arguments form of ``indexes``.</span>
<span class="sd">            One of indexes or indexes_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : DataArray</span>
<span class="sd">            Another DataArray, with this data but replaced coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray(data=np.ones((2, 3)),</span>
<span class="sd">        ...                    dims=[&#39;x&#39;, &#39;y&#39;],</span>
<span class="sd">        ...                    coords={&#39;x&#39;:</span>
<span class="sd">        ...                        range(2), &#39;y&#39;:</span>
<span class="sd">        ...                        range(3), &#39;a&#39;: (&#39;x&#39;, [3, 4])</span>
<span class="sd">        ...                    })</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        &lt;xarray.DataArray (x: 2, y: 3)&gt;</span>
<span class="sd">        array([[1., 1., 1.],</span>
<span class="sd">               [1., 1., 1.]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1</span>
<span class="sd">          * y        (y) int64 0 1 2</span>
<span class="sd">            a        (x) int64 3 4</span>
<span class="sd">        &gt;&gt;&gt; arr.set_index(x=&#39;a&#39;)</span>
<span class="sd">        &lt;xarray.DataArray (x: 2, y: 3)&gt;</span>
<span class="sd">        array([[1., 1., 1.],</span>
<span class="sd">               [1., 1., 1.]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 3 4</span>
<span class="sd">          * y        (y) int64 0 1 2</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.reset_index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_inplace</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">indexes_kwargs</span><span class="p">,</span> <span class="s2">&quot;set_index&quot;</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">merge_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dims_or_levels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Reset the specified index(es) or multi-index level(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims_or_levels : hashable or sequence of hashables</span>
<span class="sd">            Name(s) of the dimension(s) and/or multi-index level(s) that will</span>
<span class="sd">            be reset.</span>
<span class="sd">        drop : bool, optional</span>
<span class="sd">            If True, remove the specified indexes and/or multi-index levels</span>
<span class="sd">            instead of extracting them as new coordinates (default: False).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : DataArray</span>
<span class="sd">            Another dataarray, with this dataarray&#39;s data but replaced</span>
<span class="sd">            coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.set_index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_inplace</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_indexes</span><span class="p">(</span>
            <span class="n">dims_or_levels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_coords</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim_order</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dim_order_kwargs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rearrange index levels using input order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_order : optional</span>
<span class="sd">            Mapping from names matching dimensions and values given</span>
<span class="sd">            by lists representing new level orders. Every given dimension</span>
<span class="sd">            must have a multi-index.</span>
<span class="sd">        **dim_order_kwargs: optional</span>
<span class="sd">            The keyword arguments form of ``dim_order``.</span>
<span class="sd">            One of dim_order or dim_order_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : DataArray</span>
<span class="sd">            Another dataarray, with this dataarray&#39;s data but replaced</span>
<span class="sd">            coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_inplace</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">dim_order</span> <span class="o">=</span> <span class="n">either_dict_or_kwargs</span><span class="p">(</span><span class="n">dim_order</span><span class="p">,</span> <span class="n">dim_order_kwargs</span><span class="p">,</span> <span class="s2">&quot;reorder_levels&quot;</span><span class="p">)</span>
        <span class="n">replace_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">dim_order</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coordinate </span><span class="si">%r</span><span class="s2"> has no MultiIndex&quot;</span> <span class="o">%</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">replace_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">IndexVariable</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">replace_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">dimensions_kwargs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack any number of existing dimensions into a single new dimension.</span>

<span class="sd">        New dimensions will be added at the end, and the corresponding</span>
<span class="sd">        coordinate variables will be combined into a MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimensions : Mapping of the form new_name=(dim1, dim2, ...)</span>
<span class="sd">            Names of new dimensions, and the existing dimensions that they</span>
<span class="sd">            replace.</span>
<span class="sd">        **dimensions_kwargs:</span>
<span class="sd">            The keyword arguments form of ``dimensions``.</span>
<span class="sd">            One of dimensions or dimensions_kwargs must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacked : DataArray</span>
<span class="sd">            DataArray with stacked data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; arr = DataArray(np.arange(6).reshape(2, 3),</span>
<span class="sd">        ...                 coords=[(&#39;x&#39;, [&#39;a&#39;, &#39;b&#39;]), (&#39;y&#39;, [0, 1, 2])])</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        &lt;xarray.DataArray (x: 2, y: 3)&gt;</span>
<span class="sd">        array([[0, 1, 2],</span>
<span class="sd">               [3, 4, 5]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) |S1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 0 1 2</span>
<span class="sd">        &gt;&gt;&gt; stacked = arr.stack(z=(&#39;x&#39;, &#39;y&#39;))</span>
<span class="sd">        &gt;&gt;&gt; stacked.indexes[&#39;z&#39;]</span>
<span class="sd">        MultiIndex(levels=[[&#39;a&#39;, &#39;b&#39;], [0, 1, 2]],</span>
<span class="sd">                   codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]],</span>
<span class="sd">                   names=[&#39;x&#39;, &#39;y&#39;])</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.unstack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="o">**</span><span class="n">dimensions_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unstack existing dimensions corresponding to MultiIndexes into</span>
<span class="sd">        multiple new dimensions.</span>

<span class="sd">        New dimensions will be added at the end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable or sequence of hashable, optional</span>
<span class="sd">            Dimension(s) over which to unstack. By default unstacks all</span>
<span class="sd">            MultiIndexes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unstacked : DataArray</span>
<span class="sd">            Array with unstacked data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; arr = DataArray(np.arange(6).reshape(2, 3),</span>
<span class="sd">        ...                 coords=[(&#39;x&#39;, [&#39;a&#39;, &#39;b&#39;]), (&#39;y&#39;, [0, 1, 2])])</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        &lt;xarray.DataArray (x: 2, y: 3)&gt;</span>
<span class="sd">        array([[0, 1, 2],</span>
<span class="sd">               [3, 4, 5]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) |S1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 0 1 2</span>
<span class="sd">        &gt;&gt;&gt; stacked = arr.stack(z=(&#39;x&#39;, &#39;y&#39;))</span>
<span class="sd">        &gt;&gt;&gt; stacked.indexes[&#39;z&#39;]</span>
<span class="sd">        MultiIndex(levels=[[&#39;a&#39;, &#39;b&#39;], [0, 1, 2]],</span>
<span class="sd">                   codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]],</span>
<span class="sd">                   names=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; roundtripped = stacked.unstack()</span>
<span class="sd">        &gt;&gt;&gt; arr.identical(roundtripped)</span>
<span class="sd">        True</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_unstacked_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unstack DataArray expanding to Dataset along a given level of a</span>
<span class="sd">        stacked coordinate.</span>

<span class="sd">        This is the inverse operation of Dataset.to_stacked_array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Name of existing dimension to unstack</span>
<span class="sd">        level : int or str</span>
<span class="sd">            The MultiIndex level to expand to a dataset along. Can either be</span>
<span class="sd">            the integer index of the level or its name.</span>
<span class="sd">        label : int, default 0</span>
<span class="sd">            Label of the level to expand dataset along. Overrides the label</span>
<span class="sd">            argument if given.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unstacked: Dataset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import xarray as xr</span>
<span class="sd">        &gt;&gt;&gt; arr = DataArray(np.arange(6).reshape(2, 3),</span>
<span class="sd">        ...                 coords=[(&#39;x&#39;, [&#39;a&#39;, &#39;b&#39;]), (&#39;y&#39;, [0, 1, 2])])</span>
<span class="sd">        &gt;&gt;&gt; data = xr.Dataset({&#39;a&#39;: arr, &#39;b&#39;: arr.isel(y=0)})</span>
<span class="sd">        &gt;&gt;&gt; data</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (x: 2, y: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) &lt;U1 &#39;a&#39; &#39;b&#39;</span>
<span class="sd">          * y        (y) int64 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            a        (x, y) int64 0 1 2 3 4 5</span>
<span class="sd">            b        (x) int64 0 3</span>
<span class="sd">        &gt;&gt;&gt; stacked = data.to_stacked_array(&quot;z&quot;, [&#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; stacked.indexes[&#39;z&#39;]</span>
<span class="sd">        MultiIndex(levels=[[&#39;a&#39;, &#39;b&#39;], [0, 1, 2]],</span>
<span class="sd">                labels=[[0, 0, 0, 1], [0, 1, 2, -1]],</span>
<span class="sd">                names=[&#39;variable&#39;, &#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; roundtripped = stacked.to_unstacked_dataset(dim=&#39;z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; data.identical(roundtripped)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Dataset.to_stacked_array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is not a stacked coordinate&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>

        <span class="n">level_number</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level_number</span><span class="p">]</span>
        <span class="n">variable_dim</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">level_number</span><span class="p">]</span>

        <span class="c1"># pull variables out of datarray</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">variable_dim</span><span class="p">:</span> <span class="n">k</span><span class="p">})</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># unstacked dataset</span>
        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">dims</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">transpose_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new DataArray object with transposed dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *dims : hashable, optional</span>
<span class="sd">            By default, reverse the dimensions. Otherwise, reorder the</span>
<span class="sd">            dimensions to this order.</span>
<span class="sd">        transpose_coords : boolean, optional</span>
<span class="sd">            If True, also transpose the coordinates of this DataArray.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transposed : DataArray</span>
<span class="sd">            The returned DataArray&#39;s array is transposed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This operation returns a view of this array&#39;s data. It is</span>
<span class="sd">        lazy for dask-backed DataArrays but not for numpy-backed DataArrays</span>
<span class="sd">        -- the data will be fully loaded.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.transpose</span>
<span class="sd">        Dataset.transpose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;arguments to transpose (</span><span class="si">%s</span><span class="s2">) must be &quot;</span>
                    <span class="s2">&quot;permuted array dimensions (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transpose_coords</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">coord_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">coord_dims</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transpose_coords</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;This DataArray contains multi-dimensional &quot;</span>
                    <span class="s2">&quot;coordinates. In the future, these coordinates &quot;</span>
                    <span class="s2">&quot;will be transposed as well unless you specify &quot;</span>
                    <span class="s2">&quot;transpose_coords=False.&quot;</span><span class="p">,</span>
                    <span class="ne">FutureWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># Drop coords</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="c1"># Drop index labels along dimension</span>
    <span class="nd">@overload</span>  <span class="c1"># noqa: F811</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span>  <span class="c1"># array-like</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>  <span class="c1"># noqa: F811</span>
        <span class="sd">&quot;&quot;&quot;Drop coordinates or index labels from this DataArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : hashable or sequence of hashables</span>
<span class="sd">            Name(s) of coordinates or index labels to drop.</span>
<span class="sd">            If dim is not None, labels can be any array-like.</span>
<span class="sd">        dim : hashable, optional</span>
<span class="sd">            Dimension along which to drop index labels. By default (if</span>
<span class="sd">            ``dim is None``), drops coordinates rather than index labels.</span>
<span class="sd">        errors: {&#39;raise&#39;, &#39;ignore&#39;}, optional</span>
<span class="sd">            If &#39;raise&#39; (default), raises a ValueError error if</span>
<span class="sd">            any of the coordinates or index labels passed are not</span>
<span class="sd">            in the array. If &#39;ignore&#39;, any given labels that are in the</span>
<span class="sd">            array are dropped and no error is raised.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new array with dropped labels for missing values along</span>
<span class="sd">        the provided dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Dimension along which to drop missing values. Dropping along</span>
<span class="sd">            multiple dimensions simultaneously is not yet supported.</span>
<span class="sd">        how : {&#39;any&#39;, &#39;all&#39;}, optional</span>
<span class="sd">            * any : if any NA values are present, drop that label</span>
<span class="sd">            * all : if all values are NA, drop that label</span>
<span class="sd">        thresh : int, default None</span>
<span class="sd">            If supplied, require this many non-NA values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill missing values in this object.</span>

<span class="sd">        This operation follows the normal broadcasting and alignment rules that</span>
<span class="sd">        xarray uses for binary arithmetic, except the result is aligned to this</span>
<span class="sd">        object (``join=&#39;left&#39;``) instead of aligned to the intersection of</span>
<span class="sd">        index coordinates (``join=&#39;inner&#39;``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, ndarray or DataArray</span>
<span class="sd">            Used to fill all matching missing values in this array. If the</span>
<span class="sd">            argument is a DataArray, it is first aligned with (reindexed to)</span>
<span class="sd">            this array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot provide fill value as a dictionary with &quot;</span>
                <span class="s2">&quot;fillna on a DataArray&quot;</span>
            <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">interpolate_na</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_coordinate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Interpolate values according to different methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Specifies the dimension along which to interpolate.</span>
<span class="sd">        method : {&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;,</span>
<span class="sd">                  &#39;polynomial&#39;, &#39;barycentric&#39;, &#39;krog&#39;, &#39;pchip&#39;,</span>
<span class="sd">                  &#39;spline&#39;, &#39;akima&#39;}, optional</span>
<span class="sd">            String indicating which method to use for interpolation:</span>

<span class="sd">            - &#39;linear&#39;: linear interpolation (Default). Additional keyword</span>
<span class="sd">              arguments are passed to ``numpy.interp``</span>
<span class="sd">            - &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;,</span>
<span class="sd">              &#39;polynomial&#39;: are passed to ``scipy.interpolate.interp1d``. If</span>
<span class="sd">              method==&#39;polynomial&#39;, the ``order`` keyword argument must also be</span>
<span class="sd">              provided.</span>
<span class="sd">            - &#39;barycentric&#39;, &#39;krog&#39;, &#39;pchip&#39;, &#39;spline&#39;, and `akima`: use their</span>
<span class="sd">              respective``scipy.interpolate`` classes.</span>
<span class="sd">        use_coordinate : boolean or str, default True</span>
<span class="sd">            Specifies which index to use as the x values in the interpolation</span>
<span class="sd">            formulated as `y = f(x)`. If False, values are treated as if</span>
<span class="sd">            eqaully-spaced along `dim`. If True, the IndexVariable `dim` is</span>
<span class="sd">            used. If use_coordinate is a string, it specifies the name of a</span>
<span class="sd">            coordinate variariable to use as the index.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum number of consecutive NaNs to fill. Must be greater than 0</span>
<span class="sd">            or None for no limit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataArray</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.interp</span>
<span class="sd">        scipy.interpolate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.missing</span> <span class="k">import</span> <span class="n">interp_na</span>

        <span class="k">return</span> <span class="n">interp_na</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">use_coordinate</span><span class="o">=</span><span class="n">use_coordinate</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill NaN values by propogating values forward</span>

<span class="sd">        *Requires bottleneck.*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Specifies the dimension along which to propagate values when</span>
<span class="sd">            filling.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            The maximum number of consecutive NaN values to forward fill. In</span>
<span class="sd">            other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. Must be greater</span>
<span class="sd">            than 0 or None for no limit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.missing</span> <span class="k">import</span> <span class="n">ffill</span>

        <span class="k">return</span> <span class="n">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fill NaN values by propogating values backward</span>

<span class="sd">        *Requires bottleneck.*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : str</span>
<span class="sd">            Specifies the dimension along which to propagate values when</span>
<span class="sd">            filling.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            The maximum number of consecutive NaN values to backward fill. In</span>
<span class="sd">            other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. Must be greater</span>
<span class="sd">            than 0 or None for no limit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.missing</span> <span class="k">import</span> <span class="n">bfill</span>

        <span class="k">return</span> <span class="n">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combine two DataArray objects, with union of coordinates.</span>

<span class="sd">        This operation follows the normal broadcasting and alignment rules of</span>
<span class="sd">        ``join=&#39;outer&#39;``.  Default to non-null values of array calling the</span>
<span class="sd">        method.  Use np.nan to fill in vacant cells after alignment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataArray</span>
<span class="sd">            Used to fill all matching missing values in this array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reduce this array by applying `func` along some dimension(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function which can be called in the form</span>
<span class="sd">            `f(x, axis=axis, **kwargs)` to return the result of reducing an</span>
<span class="sd">            np.ndarray over an integer valued axis.</span>
<span class="sd">        dim : hashable or sequence of hashables, optional</span>
<span class="sd">            Dimension(s) over which to apply `func`.</span>
<span class="sd">        axis : int or sequence of int, optional</span>
<span class="sd">            Axis(es) over which to repeatedly apply `func`. Only one of the</span>
<span class="sd">            &#39;dim&#39; and &#39;axis&#39; arguments can be supplied. If neither are</span>
<span class="sd">            supplied, then the reduction is calculated over the flattened array</span>
<span class="sd">            (by calling `f(x)` without an axis argument).</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the variable&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>
<span class="sd">        keepdims : bool, default False</span>
<span class="sd">            If True, the dimensions which are reduced are left in the result</span>
<span class="sd">            as dimensions of size one. Coordinates that use these dimensions</span>
<span class="sd">            are removed.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments passed on to `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : DataArray</span>
<span class="sd">            DataArray with this object&#39;s array replaced with an array with</span>
<span class="sd">            summarized data and the indicated dimension(s) removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_maybe_drop_dims</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Convert this array into a pandas object with the same shape.</span>

<span class="sd">        The type of the returned object depends on the number of DataArray</span>
<span class="sd">        dimensions:</span>

<span class="sd">        * 0D -&gt; `xarray.DataArray`</span>
<span class="sd">        * 1D -&gt; `pandas.Series`</span>
<span class="sd">        * 2D -&gt; `pandas.DataFrame`</span>
<span class="sd">        * 3D -&gt; `pandas.Panel` *(deprecated)*</span>

<span class="sd">        Only works for arrays with 3 or fewer dimensions.</span>

<span class="sd">        The DataArray constructor performs the inverse transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: consolidate the info about pandas constructors and the</span>
        <span class="c1"># attributes that correspond to their indexes into a separate module?</span>
        <span class="n">constructors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">pdcompat</span><span class="o">.</span><span class="n">Panel</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="n">constructors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot convert arrays with </span><span class="si">%s</span><span class="s2"> dimensions into &quot;</span>
                <span class="s2">&quot;pandas objects&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="n">indexes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this array and its coordinates into a tidy pandas.DataFrame.</span>

<span class="sd">        The DataFrame is indexed by the Cartesian product of index coordinates</span>
<span class="sd">        (in the form of a :py:class:`pandas.MultiIndex`).</span>

<span class="sd">        Other coordinates are included as columns in the DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot convert an unnamed DataArray to a &quot;</span>
                <span class="s2">&quot;DataFrame: use the ``name`` parameter&quot;</span>
            <span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1"># By using a unique name, we can convert a DataArray into a DataFrame</span>
        <span class="c1"># even if it shares a name with one of its coordinates.</span>
        <span class="c1"># I would normally use unique_name = object() but that results in a</span>
        <span class="c1"># dataframe with columns in the wrong order, for reasons I have not</span>
        <span class="c1"># been able to debug (possibly a pandas bug?).</span>
        <span class="n">unique_name</span> <span class="o">=</span> <span class="s2">&quot;__unique_name_identifier_z98xfz98xugfg73ho__&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataset_whole</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">unique_name</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">_to_dataframe</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">unique_name</span> <span class="k">else</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this array into a pandas.Series.</span>

<span class="sd">        The Series is indexed by the Cartesian product of index coordinates</span>
<span class="sd">        (in the form of a :py:class:`pandas.MultiIndex`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">to_index</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this array into a numpy.ma.MaskedArray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : bool</span>
<span class="sd">            If True (default) make a copy of the array in the result. If False,</span>
<span class="sd">            a MaskedArray view of DataArray.values is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            Masked where invalid values (nan or inf) occur.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># only compute lazy arrays once</span>
        <span class="n">isnull</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">isnull</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="s2">&quot;Delayed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Write DataArray contents to a netCDF file.</span>

<span class="sd">        All parameters are passed directly to `xarray.Dataset.to_netcdf`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only xarray.Dataset objects can be written to netCDF files, so</span>
<span class="sd">        the xarray.DataArray is converted to a xarray.Dataset object</span>
<span class="sd">        containing a single variable. If the DataArray has no name, or if the</span>
<span class="sd">        name is the same as a co-ordinate name, then it is given the name</span>
<span class="sd">        &#39;__xarray_dataarray_variable__&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..backends.api</span> <span class="k">import</span> <span class="n">DATAARRAY_NAME</span><span class="p">,</span> <span class="n">DATAARRAY_VARIABLE</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If no name is set then use a generic xarray name</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">DATAARRAY_VARIABLE</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="c1"># The name is the same as one of the coords names, which netCDF</span>
            <span class="c1"># doesn&#39;t support, so rename it but keep track of the old name</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">DATAARRAY_VARIABLE</span><span class="p">)</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">DATAARRAY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No problems with the name - so we&#39;re fine!</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">dataset</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this xarray.DataArray into a dictionary following xarray</span>
<span class="sd">        naming conventions.</span>

<span class="sd">        Converts all variables and attributes to native Python objects.</span>
<span class="sd">        Useful for coverting to json. To avoid datetime incompatibility</span>
<span class="sd">        use decode_times=False kwarg in xarrray.open_dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : bool, optional</span>
<span class="sd">            Whether to include the actual data in the dictionary. When set to</span>
<span class="sd">            False, returns just the schema.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.from_dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a dictionary into an xarray.DataArray</span>

<span class="sd">        Input dict can take several forms::</span>

<span class="sd">            d = {&#39;dims&#39;: (&#39;t&#39;), &#39;data&#39;: x}</span>

<span class="sd">            d = {&#39;coords&#39;: {&#39;t&#39;: {&#39;dims&#39;: &#39;t&#39;, &#39;data&#39;: t,</span>
<span class="sd">                                  &#39;attrs&#39;: {&#39;units&#39;:&#39;s&#39;}}},</span>
<span class="sd">                 &#39;attrs&#39;: {&#39;title&#39;: &#39;air temperature&#39;},</span>
<span class="sd">                 &#39;dims&#39;: &#39;t&#39;,</span>
<span class="sd">                 &#39;data&#39;: x,</span>
<span class="sd">                 &#39;name&#39;: &#39;a&#39;}</span>

<span class="sd">        where &#39;t&#39; is the name of the dimesion, &#39;a&#39; is the name of the array,</span>
<span class="sd">        and  x and t are lists, numpy.arrays, or pandas objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : dict, with a minimum structure of {&#39;dims&#39;: [..], &#39;data&#39;: [..]}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : xarray.DataArray</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.to_dict</span>
<span class="sd">        Dataset.from_dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;coords&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;dims&quot;</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot convert dict when coords are missing the key &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{dims_data}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims_data</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot convert dict without the key &#39;data&#39;&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dims&quot;</span><span class="p">),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_series</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a pandas.Series into an xarray.DataArray.</span>

<span class="sd">        If the series&#39;s index is a MultiIndex, it will be expanded into a</span>
<span class="sd">        tensor product of one-dimensional coordinates (filling in missing</span>
<span class="sd">        values with NaN). Thus this operation should be the inverse of the</span>
<span class="sd">        `to_series` method.</span>

<span class="sd">        If sparse=True, creates a sparse array instead of a dense NumPy array.</span>
<span class="sd">        Requires the pydata/sparse package.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        xarray.Dataset.from_dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_name</span> <span class="o">=</span> <span class="s2">&quot;__temporary_name&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">temp_name</span><span class="p">:</span> <span class="n">series</span><span class="p">})</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="n">temp_name</span><span class="p">])</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_cdms2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;cdms2_Variable&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this array into a cdms2.Variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..convert</span> <span class="k">import</span> <span class="n">to_cdms2</span>

        <span class="k">return</span> <span class="n">to_cdms2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cdms2</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="s2">&quot;cdms2_Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a cdms2.Variable into an xarray.DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..convert</span> <span class="k">import</span> <span class="n">from_cdms2</span>

        <span class="k">return</span> <span class="n">from_cdms2</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_iris</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;iris_Cube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert this array into a iris.cube.Cube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..convert</span> <span class="k">import</span> <span class="n">to_iris</span>

        <span class="k">return</span> <span class="n">to_iris</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_iris</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cube</span><span class="p">:</span> <span class="s2">&quot;iris_Cube&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a iris.cube.Cube into an xarray.DataArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..convert</span> <span class="k">import</span> <span class="n">from_iris</span>

        <span class="k">return</span> <span class="n">from_iris</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_all_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">compat_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Helper function for equals, broadcast_equals, and identical</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">compat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">compat_str</span><span class="p">)(</span><span class="n">y</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">dict_equiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="n">compat</span><span class="p">)</span> <span class="ow">and</span> <span class="n">compat</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">broadcast_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Two DataArrays are broadcast equal if they are equal after</span>
<span class="sd">        broadcasting them against each other such that they have the same</span>
<span class="sd">        dimensions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.equals</span>
<span class="sd">        DataArray.identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;broadcast_equals&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;True if two DataArrays have the same dimensions, coordinates and</span>
<span class="sd">        values; otherwise False.</span>

<span class="sd">        DataArrays can still be equal (like pandas objects) if they have NaN</span>
<span class="sd">        values in the same locations.</span>

<span class="sd">        This method is necessary because `v1 == v2` for ``DataArray``</span>
<span class="sd">        does element-wise comparisons (like numpy.ndarrays).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.broadcast_equals</span>
<span class="sd">        DataArray.identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;equals&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">identical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Like equals, but also checks the array name and attributes, and</span>
<span class="sd">        attributes on all coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.broadcast_equals</span>
<span class="sd">        DataArray.equal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_compat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;identical&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="n">__default_name</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]:</span>
        <span class="c1"># use the same naming heuristics as pandas:</span>
        <span class="c1"># https://github.com/ContinuumIO/blaze/issues/458#issuecomment-51936356</span>
        <span class="n">other_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__default_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other_name</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__default_name</span> <span class="ow">or</span> <span class="n">other_name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="n">new_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># currently somewhat duplicative, as only other DataArrays are</span>
        <span class="c1"># compatible with matmul</span>
        <span class="k">return</span> <span class="n">computation</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_unary_op</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">]:</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_binary_op</span><span class="p">(</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">reflexive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># see xarray.align</span>
        <span class="o">**</span><span class="n">ignored_kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">]:</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">groupby</span><span class="o">.</span><span class="n">GroupBy</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="n">align_type</span> <span class="o">=</span> <span class="n">OPTIONS</span><span class="p">[</span><span class="s2">&quot;arithmetic_join&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">join</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">join</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">align_type</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">other_variable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">other_coords</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">variable</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">other_variable</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reflexive</span>
                <span class="k">else</span> <span class="n">f</span><span class="p">(</span><span class="n">other_variable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">coords</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">_merge_raw</span><span class="p">(</span><span class="n">other_coords</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_name</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_inplace_binary_op</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">]:</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">groupby</span><span class="o">.</span><span class="n">GroupBy</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;in-place operations between a DataArray and &quot;</span>
                    <span class="s2">&quot;a grouped object are not permitted&quot;</span>
                <span class="p">)</span>
            <span class="c1"># n.b. we can&#39;t align other to self (with other.reindex_like(self))</span>
            <span class="c1"># because `other` may be converted into floats, which would cause</span>
            <span class="c1"># in-place arithmetic to fail unpredictably. Instead, we simply</span>
            <span class="c1"># don&#39;t support automatic alignment with in-place arithmetic.</span>
            <span class="n">other_coords</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">other_variable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">_merge_inplace</span><span class="p">(</span><span class="n">other_coords</span><span class="p">):</span>
                <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">other_variable</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">_copy_attrs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">Variable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">attrs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_PlotMethods</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access plotting functions for DataArray&#39;s</span>

<span class="sd">        &gt;&gt;&gt; d = DataArray([[1, 2], [3, 4]])</span>

<span class="sd">        For convenience just call this directly</span>

<span class="sd">        &gt;&gt;&gt; d.plot()</span>

<span class="sd">        Or use it as a namespace to use xarray.plot functions as</span>
<span class="sd">        DataArray methods</span>

<span class="sd">        &gt;&gt;&gt; d.plot.imshow()  # equivalent to xarray.plot.imshow(d)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_PlotMethods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_title_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the dataarray has 1 dimensional coordinates or comes from a slice</span>
<span class="sd">        we can show that info in the title</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truncate : integer</span>
<span class="sd">            maximum number of characters for title</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        title : string</span>
<span class="sd">            Can be used for plot titles</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">one_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">one_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{dim}</span><span class="s2"> = </span><span class="si">{v}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">format_item</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">one_dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">truncate</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="p">[:</span> <span class="p">(</span><span class="n">truncate</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>

        <span class="k">return</span> <span class="n">title</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;upper&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the n-th order discrete difference along given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable, optional</span>
<span class="sd">            Dimension over which to calculate the finite difference.</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            The number of times values are differenced.</span>
<span class="sd">        label : hashable, optional</span>
<span class="sd">            The new coordinate in dimension ``dim`` will have the</span>
<span class="sd">            values of either the minuend&#39;s or subtrahend&#39;s coordinate</span>
<span class="sd">            for values &#39;upper&#39; and &#39;lower&#39;, respectively.  Other</span>
<span class="sd">            values are not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        difference : same type as caller</span>
<span class="sd">            The n-th order finite difference of this object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray([5, 5, 6, 6], [[1, 2, 3, 4]], [&#39;x&#39;])</span>
<span class="sd">        &gt;&gt;&gt; arr.diff(&#39;x&#39;)</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([0, 1, 0])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) int64 2 3 4</span>
<span class="sd">        &gt;&gt;&gt; arr.diff(&#39;x&#39;, 2)</span>
<span class="sd">        &lt;xarray.DataArray (x: 2)&gt;</span>
<span class="sd">        array([ 1, -1])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">        * x        (x) int64 3 4</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataArray.differentiate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shifts</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span>
        <span class="o">**</span><span class="n">shifts_kwargs</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Shift this array by an offset along one or more dimensions.</span>

<span class="sd">        Only the data is moved; coordinates stay in place. Values shifted from</span>
<span class="sd">        beyond array bounds are replaced by NaN. This is consistent with the</span>
<span class="sd">        behavior of ``shift`` in pandas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifts : Mapping with the form of {dim: offset}</span>
<span class="sd">            Integer offset to shift along each of the given dimensions.</span>
<span class="sd">            Positive offsets shift to the right; negative offsets shift to the</span>
<span class="sd">            left.</span>
<span class="sd">        fill_value: scalar, optional</span>
<span class="sd">            Value to use for newly missing values</span>
<span class="sd">        **shifts_kwargs:</span>
<span class="sd">            The keyword arguments form of ``shifts``.</span>
<span class="sd">            One of shifts or shifts_kwarg must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : DataArray</span>
<span class="sd">            DataArray with the same coordinates and attributes but shifted</span>
<span class="sd">            data.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        roll</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray([5, 6, 7], dims=&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; arr.shift(x=1)</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([ nan,   5.,   6.])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 0 1 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span>
            <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">shifts_kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">variable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shifts</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">roll_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">shifts_kwargs</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Roll this array by an offset along one or more dimensions.</span>

<span class="sd">        Unlike shift, roll may rotate all variables, including coordinates</span>
<span class="sd">        if specified. The direction of rotation is consistent with</span>
<span class="sd">        :py:func:`numpy.roll`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifts : Mapping with the form of {dim: offset}</span>
<span class="sd">            Integer offset to rotate each of the given dimensions.</span>
<span class="sd">            Positive offsets roll to the right; negative offsets roll to the</span>
<span class="sd">            left.</span>
<span class="sd">        roll_coords : bool</span>
<span class="sd">            Indicates whether to  roll the coordinates by the offset</span>
<span class="sd">            The current default of roll_coords (None, equivalent to True) is</span>
<span class="sd">            deprecated and will change to False in a future version.</span>
<span class="sd">            Explicitly pass roll_coords to silence the warning.</span>
<span class="sd">        **shifts_kwargs : The keyword arguments form of ``shifts``.</span>
<span class="sd">            One of shifts or shifts_kwarg must be provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rolled : DataArray</span>
<span class="sd">            DataArray with the same attributes but rolled data and coordinates.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        shift</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray([5, 6, 7], dims=&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; arr.roll(x=1)</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([7, 5, 6])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) int64 2 0 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span>
            <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">roll_coords</span><span class="o">=</span><span class="n">roll_coords</span><span class="p">,</span> <span class="o">**</span><span class="n">shifts_kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform dot product of two DataArrays along their shared dims.</span>

<span class="sd">        Equivalent to taking taking tensordot over all shared dims.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataArray</span>
<span class="sd">            The other array with which the dot product is performed.</span>
<span class="sd">        dims: hashable or sequence of hashables, optional</span>
<span class="sd">            Along which dimensions to be summed over. Default all the common</span>
<span class="sd">            dimensions are summed over.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : DataArray</span>
<span class="sd">            Array resulting from the dot product over all shared dimensions.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        dot</span>
<span class="sd">        numpy.tensordot</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; da_vals = np.arange(6 * 5 * 4).reshape((6, 5, 4))</span>
<span class="sd">        &gt;&gt;&gt; da = DataArray(da_vals, dims=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span>
<span class="sd">        &gt;&gt;&gt; dm_vals = np.arange(4)</span>
<span class="sd">        &gt;&gt;&gt; dm = DataArray(dm_vals, dims=[&#39;z&#39;])</span>

<span class="sd">        &gt;&gt;&gt; dm.dims</span>
<span class="sd">        (&#39;z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; da.dims</span>
<span class="sd">        (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dot_result = da.dot(dm)</span>
<span class="sd">        &gt;&gt;&gt; dot_result.dims</span>
<span class="sd">        (&#39;x&#39;, &#39;y&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;dot products are not yet supported with Dataset objects.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;dot only operates on DataArrays.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">computation</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">]]],</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sort object by labels or values (along an axis).</span>

<span class="sd">        Sorts the dataarray, either along specified dimensions,</span>
<span class="sd">        or according to values of 1-D dataarrays that share dimension</span>
<span class="sd">        with calling object.</span>

<span class="sd">        If the input variables are dataarrays, then the dataarrays are aligned</span>
<span class="sd">        (via left-join) to the calling object prior to sorting by cell values.</span>
<span class="sd">        NaNs are sorted to the end, following Numpy convention.</span>

<span class="sd">        If multiple sorts along the same dimension is</span>
<span class="sd">        given, numpy&#39;s lexsort is performed along that dimension:</span>
<span class="sd">        https://docs.scipy.org/doc/numpy/reference/generated/numpy.lexsort.html</span>
<span class="sd">        and the FIRST key in the sequence is used as the primary sort key,</span>
<span class="sd">        followed by the 2nd key, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: hashable, DataArray, or sequence of either</span>
<span class="sd">            1D DataArray objects or name(s) of 1D variable(s) in</span>
<span class="sd">            coords whose values are used to sort this array.</span>
<span class="sd">        ascending: boolean, optional</span>
<span class="sd">            Whether to sort by ascending or descending order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted: DataArray</span>
<span class="sd">            A new dataarray where all the specified dims are sorted by dim</span>
<span class="sd">            labels.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.random.rand(5),</span>
<span class="sd">        ...                   coords=[pd.date_range(&#39;1/1/2000&#39;, periods=5)],</span>
<span class="sd">        ...                   dims=&#39;time&#39;)</span>
<span class="sd">        &gt;&gt;&gt; da</span>
<span class="sd">        &lt;xarray.DataArray (time: 5)&gt;</span>
<span class="sd">        array([ 0.965471,  0.615637,  0.26532 ,  0.270962,  0.552878])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 2000-01-01 2000-01-02 2000-01-03 ...</span>

<span class="sd">        &gt;&gt;&gt; da.sortby(da)</span>
<span class="sd">        &lt;xarray.DataArray (time: 5)&gt;</span>
<span class="sd">        array([ 0.26532 ,  0.270962,  0.552878,  0.615637,  0.965471])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * time     (time) datetime64[ns] 2000-01-03 2000-01-04 2000-01-05 ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compute the qth quantile of the data along the specified dimension.</span>

<span class="sd">        Returns the qth quantiles(s) of the array elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float in range of [0,1] or array-like of floats</span>
<span class="sd">            Quantile to compute, which must be between 0 and 1 inclusive.</span>
<span class="sd">        dim : hashable or sequence of hashable, optional</span>
<span class="sd">            Dimension(s) over which to apply quantile.</span>
<span class="sd">        interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">            This optional parameter specifies the interpolation method to</span>
<span class="sd">            use when the desired quantile lies between two data points</span>
<span class="sd">            ``i &lt; j``:</span>

<span class="sd">                - linear: ``i + (j - i) * fraction``, where ``fraction`` is</span>
<span class="sd">                  the fractional part of the index surrounded by ``i`` and</span>
<span class="sd">                  ``j``.</span>
<span class="sd">                - lower: ``i``.</span>
<span class="sd">                - higher: ``j``.</span>
<span class="sd">                - nearest: ``i`` or ``j``, whichever is nearest.</span>
<span class="sd">                - midpoint: ``(i + j) / 2``.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        quantiles : DataArray</span>
<span class="sd">            If `q` is a single quantile, then the result</span>
<span class="sd">            is a scalar. If multiple percentiles are given, first axis of</span>
<span class="sd">            the result corresponds to the quantile and a quantile dimension</span>
<span class="sd">            is added to the return array. The other dimensions are the</span>
<span class="sd">             dimensions that remain after the reduction of the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">pct</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Ranks the data.</span>

<span class="sd">        Equal values are assigned a rank that is the average of the ranks that</span>
<span class="sd">        would have been otherwise assigned to all of the values within that</span>
<span class="sd">        set.  Ranks begin at 1, not 0. If pct, computes percentage ranks.</span>

<span class="sd">        NaNs in the input array are returned as NaNs.</span>

<span class="sd">        The `bottleneck` library is required.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : hashable</span>
<span class="sd">            Dimension over which to compute rank.</span>
<span class="sd">        pct : bool, optional</span>
<span class="sd">            If True, compute percentage ranks, otherwise compute integer ranks.</span>
<span class="sd">        keep_attrs : bool, optional</span>
<span class="sd">            If True, the dataset&#39;s attributes (`attrs`) will be copied from</span>
<span class="sd">            the original object to the new one.  If False (default), the new</span>
<span class="sd">            object will be returned without attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranked : DataArray</span>
<span class="sd">            DataArray with the same coordinates and dtype &#39;float64&#39;.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; arr = xr.DataArray([5, 6, 7], dims=&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; arr.rank(&#39;x&#39;)</span>
<span class="sd">        &lt;xarray.DataArray (x: 3)&gt;</span>
<span class="sd">        array([ 1.,   2.,   3.])</span>
<span class="sd">        Dimensions without coordinates: x</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">,</span> <span class="n">keep_attrs</span><span class="o">=</span><span class="n">keep_attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">edge_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Differentiate the array with the second order accurate central</span>
<span class="sd">        differences.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord: hashable</span>
<span class="sd">            The coordinate to be used to compute the gradient.</span>
<span class="sd">        edge_order: 1 or 2. Default 1</span>
<span class="sd">            N-th order accurate differences at the boundaries.</span>
<span class="sd">        datetime_unit: None or any of {&#39;Y&#39;, &#39;M&#39;, &#39;W&#39;, &#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;, &#39;ms&#39;,</span>
<span class="sd">            &#39;us&#39;, &#39;ns&#39;, &#39;ps&#39;, &#39;fs&#39;, &#39;as&#39;}</span>
<span class="sd">            Unit to compute gradient. Only valid for datetime coordinate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        differentiated: DataArray</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.gradient: corresponding numpy function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.arange(12).reshape(4, 3), dims=[&#39;x&#39;, &#39;y&#39;],</span>
<span class="sd">        ...                   coords={&#39;x&#39;: [0, 0.1, 1.1, 1.2]})</span>
<span class="sd">        &gt;&gt;&gt; da</span>
<span class="sd">        &lt;xarray.DataArray (x: 4, y: 3)&gt;</span>
<span class="sd">        array([[ 0,  1,  2],</span>
<span class="sd">               [ 3,  4,  5],</span>
<span class="sd">               [ 6,  7,  8],</span>
<span class="sd">               [ 9, 10, 11]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) float64 0.0 0.1 1.1 1.2</span>
<span class="sd">        Dimensions without coordinates: y</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; da.differentiate(&#39;x&#39;)</span>
<span class="sd">        &lt;xarray.DataArray (x: 4, y: 3)&gt;</span>
<span class="sd">        array([[30.      , 30.      , 30.      ],</span>
<span class="sd">               [27.545455, 27.545455, 27.545455],</span>
<span class="sd">               [27.545455, 27.545455, 27.545455],</span>
<span class="sd">               [30.      , 30.      , 30.      ]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) float64 0.0 0.1 1.1 1.2</span>
<span class="sd">        Dimensions without coordinates: y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">edge_order</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span> <span class="n">datetime_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; integrate the array with the trapezoidal rule.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature is limited to simple cartesian geometry, i.e. coord</span>
<span class="sd">            must be one dimensional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim: hashable, or a sequence of hashable</span>
<span class="sd">            Coordinate(s) used for the integration.</span>
<span class="sd">        datetime_unit: str, optional</span>
<span class="sd">            Can be used to specify the unit if datetime coordinate is used.</span>
<span class="sd">            One of {&#39;Y&#39;, &#39;M&#39;, &#39;W&#39;, &#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;,</span>
<span class="sd">                    &#39;ps&#39;, &#39;fs&#39;, &#39;as&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integrated: DataArray</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.trapz: corresponding numpy function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; da = xr.DataArray(np.arange(12).reshape(4, 3), dims=[&#39;x&#39;, &#39;y&#39;],</span>
<span class="sd">        ...                   coords={&#39;x&#39;: [0, 0.1, 1.1, 1.2]})</span>
<span class="sd">        &gt;&gt;&gt; da</span>
<span class="sd">        &lt;xarray.DataArray (x: 4, y: 3)&gt;</span>
<span class="sd">        array([[ 0,  1,  2],</span>
<span class="sd">               [ 3,  4,  5],</span>
<span class="sd">               [ 6,  7,  8],</span>
<span class="sd">               [ 9, 10, 11]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * x        (x) float64 0.0 0.1 1.1 1.2</span>
<span class="sd">        Dimensions without coordinates: y</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; da.integrate(&#39;x&#39;)</span>
<span class="sd">        &lt;xarray.DataArray (y: 3)&gt;</span>
<span class="sd">        array([5.4, 6.6, 7.8])</span>
<span class="sd">        Dimensions without coordinates: y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">datetime_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unify_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Unify chunk size along all chunked dimensions of this DataArray.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        DataArray with consistent chunk sizes for all dask-array variables</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        dask.array.core.unify_chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_temp_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">unify_chunks</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_temp_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_blocks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="s2">&quot;Callable[..., T_DSorDA]&quot;</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;T_DSorDA&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to each chunk of this DataArray. This method is experimental</span>
<span class="sd">        and its signature may change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func: callable</span>
<span class="sd">            User-provided function that accepts a DataArray as its first parameter. The</span>
<span class="sd">            function will receive a subset of this DataArray, corresponding to one chunk</span>
<span class="sd">            along each chunked dimension. ``func`` will be executed as</span>
<span class="sd">            ``func(obj_subset, *args, **kwargs)``.</span>

<span class="sd">            The function will be first run on mocked-up data, that looks like this array</span>
<span class="sd">            but has sizes 0, to determine properties of the returned object such as</span>
<span class="sd">            dtype, variable names, new dimensions and new indexes (if any).</span>

<span class="sd">            This function must return either a single DataArray or a single Dataset.</span>

<span class="sd">            This function cannot change size of existing dimensions, or add new chunked</span>
<span class="sd">            dimensions.</span>
<span class="sd">        args: Sequence</span>
<span class="sd">            Passed verbatim to func after unpacking, after the sliced DataArray. xarray</span>
<span class="sd">            objects, if any, will not be split by chunks. Passing dask collections is</span>
<span class="sd">            not allowed.</span>
<span class="sd">        kwargs: Mapping</span>
<span class="sd">            Passed verbatim to func after unpacking. xarray objects, if any, will not be</span>
<span class="sd">            split by chunks. Passing dask collections is not allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A single DataArray or Dataset with dask backend, reassembled from the outputs of</span>
<span class="sd">        the function.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is designed for when one needs to manipulate a whole xarray object</span>
<span class="sd">        within each chunk. In the more common case where one can work on numpy arrays,</span>
<span class="sd">        it is recommended to use apply_ufunc.</span>

<span class="sd">        If none of the variables in this DataArray is backed by dask, calling this</span>
<span class="sd">        method is equivalent to calling ``func(self, *args, **kwargs)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.map_blocks, xarray.apply_ufunc, xarray.map_blocks,</span>
<span class="sd">        xarray.Dataset.map_blocks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.parallel</span> <span class="k">import</span> <span class="n">map_blocks</span>

        <span class="k">return</span> <span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># this needs to be at the end, or mypy will confuse with `str`</span>
    <span class="c1"># https://mypy.readthedocs.io/en/latest/common_issues.html#dealing-with-conflicting-names</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">StringAccessor</span><span class="p">)</span>


<span class="c1"># priority most be higher than Variable to properly work with binary ufuncs</span>
<span class="n">ops</span><span class="o">.</span><span class="n">inject_all_ops_and_reduce_methods</span><span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019, Creare

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>